#pragma version 8

// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // Handle Create App
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz opt_in
txn OnCompletion
pushint 2 // CloseOut
==
bnz close_out
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz update_app
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz delete_app
err // unexpected value

// block opt_in
opt_in:
  // Disallow Opt In
  // exit(0)
  pushint 0
  return

// block close_out
close_out:
  // Disallow Closing Out
  // exit(0)
  pushint 0
  return

// block update_app
update_app:
  // Handle Update App
  // Only allow the Creator to update the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block delete_app
delete_app:
  // Handle Delete App
  // Only allow the Creator to delete the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block main
main:
  
  // int currency = Txn.Assets[0] [slot 0]
  txna Assets 0
  store 0 // currency
  // int n [slot 1]
  // int d [slot 2]
  // bytes addr [slot 3]
  
  // USDC
  // if currency == 10458941:
    load 0 // currency
    pushint 10458941
    ==
    bz l1_elif_0
    // then:
      // addr UDFWT5DW3X5RZQYXKQEMZ6MRWAEYHWYP7YUAPZKPW6WJK3JH3OZPL7PO2Y
      // addr = "\xa0\xcbi\xf4v\xdd\xfb\x1c\xc3\x17T\x08\xcc\xf9\x91\xb0\t\x83\xdb\x0f\xfe(\x07\xe5O\xb7\xac\x95m'\xdb\xb2"
      pushbytes "\xa0\xcbi\xf4v\xdd\xfb\x1c\xc3\x17T\x08\xcc\xf9\x91\xb0\t\x83\xdb\x0f\xfe(\x07\xe5O\xb7\xac\x95m'\xdb\xb2"
      store 3 // addr
      // assert(Txn.Accounts[1] == addr)
      txna Accounts 1
      load 3 // addr
      ==
      assert
      // n, d = tinyman()
      callsub __func__tinyman
      store 1 // n
      store 2 // d
      // TINYAU
    b l1_end
    l1_elif_0:
    // elif currency == 21582981:
    load 0 // currency
    pushint 21582981
    ==
    bz l1_else
      // addr DNPVHOLSYCBDA6UAB3MREZN6W4MZZV4OL227B5ABABQTHCJFMLD345JPXE
      // addr = "\x1b_S\xb9r\xc0\x820z\x80\x0e\xd9\x12e\xbe\xb7\x19\x9c\xd7\x8e^\xb5\xf0\xf4\x01\x00a3\x89%b\xc7"
      pushbytes "\x1b_S\xb9r\xc0\x820z\x80\x0e\xd9\x12e\xbe\xb7\x19\x9c\xd7\x8e^\xb5\xf0\xf4\x01\x00a3\x89%b\xc7"
      store 3 // addr
      // assert(Txn.Accounts[1] == addr)
      txna Accounts 1
      load 3 // addr
      ==
      assert
      // n, d = tinyman()
      callsub __func__tinyman
      store 1 // n
      store 2 // d
    b l1_end
    l1_else:
    // else:
      // TODO if itob(n) starts with "SUBJECTIVE", its a mistake
      // abi_return("SUBJECTIVE")
      pushbytes "SUBJECTIVE"
      callsub __func__abi_return
      // exit(1)
      pushint 1
      return
    l1_end: // end
  
  // bytes nb = abi_encode_uint64(n) [slot 4]
  load 1 // n
  callsub __func__abi_encode_uint64
  store 4 // nb
  // bytes db = abi_encode_uint64(d) [slot 5]
  load 2 // d
  callsub __func__abi_encode_uint64
  store 5 // db
  // abi_return(concat(nb, db))
  load 4 // nb
  load 5 // db
  concat
  callsub __func__abi_return
  // exit(1)
  pushint 1
  return
  
  // block add:
  //     # Add 2 integers
  //     int x = btoi(Txn.ApplicationArgs[1])
  //     int y = btoi(Txn.ApplicationArgs[2])
  //     int result = x + y
  //     abi_return(abi_encode_uint64(result))
  //     exit(1)
  // end
  
  // block mulw:
  //     # Multiply 2 integers, returing a uint128
  //     bytes x = Txn.ApplicationArgs[1]
  //     bytes y = Txn.ApplicationArgs[2]
  //     bytes result = x b* y
  //     abi_return(abi_encode_uint128(result))
  //     exit(1)
  // end
  
  
  // block hello:
  //     # Return a greeting
  //     bytes name = abi_decode_string(Txn.ApplicationArgs[1])
  //     bytes result = concat("Hello ", name)
  //     abi_return(abi_encode_string(result))
  //     exit(1)
  // end
  
  // block send:
  //     # Send some Algo to the given address
  //     bytes address = Txn.ApplicationArgs[1]
  //     inner_txn:
  //         TypeEnum: Pay
  //         Receiver: address
  //         Amount: 10000000
  //         Fee: 0
  //     end
  //     exit(1)
  // end
  
  // block store_data:
  //     # Store some fixed size data in a box with the specified key
  //     bytes key = Txn.ApplicationArgs[1]
  //     bytes data = Txn.ApplicationArgs[2]
  //     box_put(key, data)
  //     exit(1)
  // end
  
  // block store_tuple:
  //     # Store some structured data in a box with the specified key
  //     bytes key = Txn.ApplicationArgs[1]
  //     # Item data = Txn.ApplicationArgs[2]
  //     # make some assertion about the data for the fun of it
  //     # assert(data.owner == Txn.Sender)
  //     # box_put(key, data)
  //     exit(1)
  // end
  
  // block balance:
  //     # Return balance of the specified account
  //     int result = balance(Txn.Accounts[btoi(Txn.ApplicationArgs[1])])
  //     abi_return(abi_encode_uint64(result))
  //     exit(1)
  // end

// func tinyman() int, int:
__func__tinyman:
// int asset_1_reserves [slot 6]
// _, asset_1_reserves = app_local_get_ex(Txn.Accounts[1], LP_APP, ASSET_1_KEY)
txna Accounts 1
pushint 148607000 // LP_APP
pushbytes "asset_1_reserves" // ASSET_1_KEY
app_local_get_ex
pop // discarding value for _
store 6 // asset_1_reserves
// int asset_2_reserves [slot 7]
// _, asset_2_reserves = app_local_get_ex(Txn.Accounts[1], LP_APP, ASSET_2_KEY)
txna Accounts 1
pushint 148607000 // LP_APP
pushbytes "asset_2_reserves" // ASSET_2_KEY
app_local_get_ex
pop // discarding value for _
store 7 // asset_2_reserves

// return asset_1_reserves, asset_2_reserves
load 7 // asset_2_reserves
load 6 // asset_1_reserves
retsub

// func is_obj():
//     return
// end

// func abi_return_int(result):
//     # log(concat("\x15\x1f\x7c\x75", result))
//     # log(result)
//     int r = result
//     teal:
//         store 0
//     end
//     log(itob(result0))
//     return
// end

// func abi_return(result: bytes):
__func__abi_return:
store 8 // result
// log(concat("\x15\x1f\x7c\x75", result))
// log(result)
load 8 // result
log
// return
retsub

// func abi_decode_string(value: bytes) bytes:
//     # return the content portion of the string, skipping the first 2 bytes which encode the length
//     return extract(2, 0, value)
// end

// func abi_encode_string(value: bytes) bytes:
//     # return the bytestring with a uint16 prefix denoting the length
//     return concat(extract(6, 2, itob(len(value))), value)
// end

// func abi_encode_uint64(value: int) bytes:
__func__abi_encode_uint64:
store 9 // value
// return itob(value)
load 9 // value
itob
retsub

// func abi_encode_uint32(value: int) bytes:
//     # return the last 4 bytes
//     return extract(4, 4, itob(value))
// end

// func abi_encode_uint16(value: int) bytes:
//     # return the last 2 bytes
//     return extract(6, 2, itob(value))
// end

// func abi_encode_uint8(value: int) bytes:
//     # return the last 1 byte
//     return extract(7, 1, itob(value))
// end

// func abi_encode_uint128(value: bytes) bytes:
//     # return 16 bytes with zero padding
//     return bzero(16) b| value
// end
