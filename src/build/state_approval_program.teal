#pragma version 8

// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // Handle Create App
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz opt_in
txn OnCompletion
pushint 2 // CloseOut
==
bnz close_out
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz update_app
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz delete_app
err // unexpected value

// block opt_in
opt_in:
  // Disallow Opt In
  // exit(0)
  pushint 0
  return

// block close_out
close_out:
  // Disallow Closing Out
  // exit(0)
  pushint 0
  return

// block update_app
update_app:
  // Handle Update App
  // Only allow the Creator to update the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block delete_app
delete_app:
  // Handle Delete App
  // Only allow the Creator to delete the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block main
main:
  
  // safety
  // int e = Global.GroupSize-1 [slot 0]
  global GroupSize
  pushint 1
  -
  store 0 // e
  // for i in 0:e:
    pushint 0
    store 1 // i
    l1_for:
    load 1 // i
    load 0 // e
    ==
    bnz l1_end
    
    // assert(Gtxn[i].RekeyTo == Global.ZeroAddress)
    load 1 // i
    gtxns RekeyTo
    global ZeroAddress
    ==
    assert
    // assert(Gtxn[i].AssetCloseTo == Global.ZeroAddress)
    load 1 // i
    gtxns AssetCloseTo
    global ZeroAddress
    ==
    assert
    // assert(Gtxn[i].CloseRemainderTo == Global.ZeroAddress)
    load 1 // i
    gtxns CloseRemainderTo
    global ZeroAddress
    ==
    assert
    
    // stay empty
    // if Gtxn[i].TypeEnum == Pay:
      load 1 // i
      gtxns TypeEnum
      pushint 1 // Pay
      ==
      bz l2_end
      // then:
        // assert(Gtxn[i].Receiver != Global.CurrentApplicationAddress)
        load 1 // i
        gtxns Receiver
        global CurrentApplicationAddress
        !=
        assert
      l2_end: // end
    // if Gtxn[i].TypeEnum == Axfer:
      load 1 // i
      gtxns TypeEnum
      pushint 4 // Axfer
      ==
      bz l3_end
      // then:
        // assert(Gtxn[i].AssetReceiver != Global.CurrentApplicationAddress)
        load 1 // i
        gtxns AssetReceiver
        global CurrentApplicationAddress
        !=
        assert
      l3_end: // end
    
    load 1 // i
    pushint 1
    +
    store 1 // i
    b l1_for
    l1_end: // end
  
  
  
  // int currency = Txn.Assets[0] [slot 1]
  txna Assets 0
  store 1 // currency
  // int n = 0 [slot 2]
  pushint 0
  store 2 // n
  // int d = 0 [slot 3]
  pushint 0
  store 3 // d
  // bytes addr [slot 4]
  
  // USDC
  // if currency == 10458941:
    load 1 // currency
    pushint 10458941
    ==
    bz l4_elif_0
    // then:
      // addr UDFWT5DW3X5RZQYXKQEMZ6MRWAEYHWYP7YUAPZKPW6WJK3JH3OZPL7PO2Y
      // addr = "\xa0\xcbi\xf4v\xdd\xfb\x1c\xc3\x17T\x08\xcc\xf9\x91\xb0\t\x83\xdb\x0f\xfe(\x07\xe5O\xb7\xac\x95m'\xdb\xb2"
      pushbytes "\xa0\xcbi\xf4v\xdd\xfb\x1c\xc3\x17T\x08\xcc\xf9\x91\xb0\t\x83\xdb\x0f\xfe(\x07\xe5O\xb7\xac\x95m'\xdb\xb2"
      store 4 // addr
      // assert(Txn.Accounts[1] == addr)
      txna Accounts 1
      load 4 // addr
      ==
      assert
      // n, d = tinyman()
      callsub __func__tinyman
      store 2 // n
      store 3 // d
      // TINYAU
    b l4_end
    l4_elif_0:
    // elif currency == 21582981:
    load 1 // currency
    pushint 21582981
    ==
    bz l4_end
      // addr DNPVHOLSYCBDA6UAB3MREZN6W4MZZV4OL227B5ABABQTHCJFMLD345JPXE
      // addr = "\x1b_S\xb9r\xc0\x820z\x80\x0e\xd9\x12e\xbe\xb7\x19\x9c\xd7\x8e^\xb5\xf0\xf4\x01\x00a3\x89%b\xc7"
      pushbytes "\x1b_S\xb9r\xc0\x820z\x80\x0e\xd9\x12e\xbe\xb7\x19\x9c\xd7\x8e^\xb5\xf0\xf4\x01\x00a3\x89%b\xc7"
      store 4 // addr
      // assert(Txn.Accounts[1] == addr)
      txna Accounts 1
      load 4 // addr
      ==
      assert
      // n, d = tinyman()
      callsub __func__tinyman
      store 2 // n
      store 3 // d
    l4_end: // end
  
  // bytes nb = abi_encode_uint64(n) [slot 5]
  load 2 // n
  callsub __func__abi_encode_uint64
  store 5 // nb
  // bytes db = abi_encode_uint64(d) [slot 6]
  load 3 // d
  callsub __func__abi_encode_uint64
  store 6 // db
  // abi_return(concat(nb, db))
  load 5 // nb
  load 6 // db
  concat
  callsub __func__abi_return
  // exit(1)
  pushint 1
  return

// func tinyman() int, int:
__func__tinyman:
// int asset_1_reserves [slot 7]
// _, asset_1_reserves = app_local_get_ex(Txn.Accounts[1], LP_APP, ASSET_1_KEY)
txna Accounts 1
pushint 148607000 // LP_APP
pushbytes "asset_1_reserves" // ASSET_1_KEY
app_local_get_ex
pop // discarding value for _
store 7 // asset_1_reserves
// int asset_2_reserves [slot 8]
// _, asset_2_reserves = app_local_get_ex(Txn.Accounts[1], LP_APP, ASSET_2_KEY)
txna Accounts 1
pushint 148607000 // LP_APP
pushbytes "asset_2_reserves" // ASSET_2_KEY
app_local_get_ex
pop // discarding value for _
store 8 // asset_2_reserves

// return asset_1_reserves, asset_2_reserves
load 8 // asset_2_reserves
load 7 // asset_1_reserves
retsub

// func abi_return(result: bytes):
__func__abi_return:
store 9 // result
// log(concat("\x15\x1f\x7c\x75", result))
// log(result)
load 9 // result
log
// return
retsub

// func abi_encode_uint64(value: int) bytes:
__func__abi_encode_uint64:
store 10 // value
// return itob(value)
load 10 // value
itob
retsub
